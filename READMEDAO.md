Ура, практика! Пришло время усовершенствовать Filmorate с помощью полученных знаний о базах данных. На этот раз вы добавите ещё одну функциональность — сохранение состояния данных после перезапуска. Уже к концу задания у вас будет завершённое приложение для работы с фильмами и оценками пользователей. Внимание, мотор!

## Организация

В этом спринте вы будете работать в новой ветке. Назовите её add-database. Название ветки важно, потому что к ней привязаны тесты.

## Создание базы данных

В уроках спринта вы использовали PostgreSQL — популярную в индустрии базу данных. Однако сейчас вы будете работать с другой базой. Она называется H2. H2 не требует отдельной установки. Её можно встроить в приложение — достаточно добавить зависимость в сборку проекта. Использование встроенной базы данных упростит тестирование вашего приложения в GitHub.

### База будет работать в двух режимах:
- В режиме тестирования H2 будет хранить данные в памяти. Это позволит базе быстро запуститься на время тестов и удалить все тестовые данные после их завершения.
- В рабочем режиме H2 будет хранить данные в файле на жёстком диске. Это не позволит рабочим данным потеряться между запусками.
### Почитайте, как использовать H2 со Spring Boot, [в этой статье](https://www.baeldung.com/spring-boot-h2-database). Далее следуйте нашей инструкции:
- Добавьте в проект зависимости com.h2database.h2, org.springframework.boot.spring-boot-starter-jdbc и org.springframework.boot.spring-boot-starter-test.
- Сконфигурируйте базу данных для рабочего режима с помощью файла настроек application.properties.
````
spring.sql.init.mode=always
# в jdbc-url укажите, что данные нужно сохранять в файл
spring.datasource.url=jdbc:h2:file:./db/filmorate
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=password
````
- Сформируйте структуру базы данных — для этого реализуйте схему, которую вы нарисовали в предыдущем спринте. Обратите внимание: база будет работать, пока работает само приложение. Чтобы подключиться к БД напрямую, используйте встроенный в IntelliJ IDEA функционал или клиент DBeaver.
- Не забудьте обновить модели данных в коде — добавьте новые поля.
- Соберите SQL-запросы, формирующие структуру вашей базы, в отдельный файл в src/main/resources с названием schema.sql — так схема будет создаваться заново при каждом запуске приложения.
### Подсказка: про файл schema.sql
````
Включите в файл schema.sql создание таблиц. Если вам нужны некоторые данные в базе, их инициализация обычно описывается 
в файле data.sql — создайте его там же, где и schema.sql.

Чтобы избежать ошибок, связанных с многократным применением скрипта к БД, добавьте условие IF NOT EXISTS 
при создании таблиц и индексов.
````
## Работа с DAO
Таблицы созданы. Теперь можно заняться кодом, который будет отвечать за получение данных из базы.

- Вам пригодятся созданные ранее интерфейсы UserStorage и FilmStorage. Напишите для них новую имплементацию — например, UserDbStorage и FilmDbStorage. Эти классы будут DAO — объектами доступа к данным.
- Напишите в DAO соответствующие мапперы и методы, позволяющие сохранять пользователей и фильмы в базу данных и получать их из неё.
### Подсказка: про аннотацию @Qualifier
````
Чтобы Spring мог работать с новыми компонентами и отличать их от старых хранилищ, воспользуйтесь аннотацией @Qualifier. 
Пример её использования можно найти в этой статье.
````
### Подсказка: как проверить, что база данных успешно настроена
````
Убедитесь, что ваше приложение работает с базой данных. Создайте новый фильм и пользователя, а потом 
перезапустите проект — данные должны сохраниться в базе и быть доступны после перезапуска.
````
### Подсказка: как реализовать CRUD-операции с использованием JdbcTemplate
````
В теме о работе с БД вы узнали, как делать выборку данных из базы с помощью SQL-запросов и JdbcTemplate. Для реализации методов, 
описанных в интерфейсах хранилищ, вам также потребуется добавлять новые данные и обновлять имеющиеся. Почитайте, как это сделать, в этой статье.
````

## Тестирование
Тестировать приложение вручную — трудоёмкий процесс, который сопряжён со многими ограничениями. Использовать Postman-запросы проще, но такой способ не позволяет протестировать имплементацию методов.

Вам предстоит реализовать интеграционное тестирование (англ. integration testing). С помощью него можно проверить работу приложения с зависимостями — например, с базой данных. Резидентная база данных обеспечит автономность ваших интеграционных тестов — перед каждым их запуском Spring будет создавать новую, чистую БД.

Подробнее об этом виде тестирования мы расскажем в следующем модуле, но простейшую его реализацию вы выполните уже сейчас.

````JAVA
@JdbcTest
@AutoConfigureTestDatabase
@RequiredArgsConstructor(onConstructor_ = @Autowired)
@Import({UserDbStorage.class})
class FilmoRateApplicationTests {
private final UserDbStorage userStorage;

    @Test
    public void testFindUserById() {

        Optional<User> userOptional = userStorage.findUserById(1);

        assertThat(userOptional)
                .isPresent()
                .hasValueSatisfying(user ->
                        assertThat(user).hasFieldOrPropertyWithValue("id", 1)
                );
    }
}
````
### Обратите внимание:
- по аннотации @AutoConfigureTestDatabase Spring понимает, что перед запуском теста необходимо сконфигурировать тестовую БД вместо основной;
- аннотация @JdbcTest, которой помечается класс с тестами, говорит, что перед запуском этих тестов необходимо создать тестовый контекст: в него нужно поместить бины для работы с базой данных, например — полностью настроенный экземпляр DataSource;
- элемент onConstructor_ аннотации @RequiredArgsConstructor указывает, что конструктор, который будет сгенерирован библиотекой Lombok, необходимо аннотировать @Autowired. Это нужно из-за того, что тестовые классы запускаются не как обычные Spring-приложения, поэтому конструктор класса обязательно должен быть аннотирован @Autowired, чтобы внедрение зависимостей через конструктор работало. 

Во время инициализации тестовой базы данных Spring прочитает SQL-запросы из стандартного файла schema.sql, который вы собрали в начале задания, и выполнит их для текущей базы данных. Этот скрипт должен создать схему в тестовой БД. Для этого не забудьте добавить в файл application.properties настройки подключения к базе данных:
- url: jdbc:h2:file:./db/filmorate
- driverClassName: org.h2.Driver

Теперь можно написать интеграционные тесты для DAO-объектов приложения по примеру выше. С помощью них вы проверите, правильно ли работают ваши запросы к базе данных. Убедитесь, что все публичные методы хранилища покрыты тестами.
## Доработка бизнес-логики
Осталось несколько штрихов. Добавьте в код недостающие DAO-объекты, соответствующие вашей схеме, и завершите описание бизнес-логики. После этого протестируйте поведение программы.

Поскольку в программе появились новые сущности, то нужно обеспечить доступ к ним. Добавьте следующие эндпоинты:
- Для получения списка всех жанров и для получения жанра по его идентификатору:
  - GET /genres — возвращает список объектов содержащих жанр
  - GET /genres/{id} — возвращает объект содержащий жанр с идентификатором id
  - Пример возвращаемого значения 
  ````
    {
    “id”: 1,
    “name”: “Комедия”
    }
    ````
- Для получения списка всех рейтингов и для получения рейтинга по его идентификатору:
  - GET /mpa — возвращает список объектов содержащих рейтинг 
  - GET /mpa/{id} — возвращает объект содержащий рейтинг с идентификатором id 
  - Пример возвращаемого значения
    ````    
    {
    “id”: 1,
    “name”: “G”
    }
    ````
При создании и получении фильмов достаточно передать список идентификаторов жанров и идентификатор рейтинга. Эти же данные должны передаваться при обновлении, создании и получении фильмов — если нужно, обновите эти эндпоинты.

И последнее небольшое изменение: дружба должна стать односторонней. Теперь, если пользователь отправляет заявку в друзья, он добавляет другого человека в свой список друзей, но сам в его список не попадает.

### Подсказка-напоминание
````
Не забудьте: у пользователей Filmorate должна быть возможность лайкать фильмы и добавлять друг друга в друзья с подтверждением дружбы.
````
## Финальный кадр

Убедитесь, что ваше приложение работает правильно. Проверьте его дополнительно с помощью тестов Postman: sprint.json.
````
Эти же тесты запускаются в GitHub при создании pull request’а. Проверьте их локально, прежде чем делать pull request.
````